### Начинай с конца!

Возьмем сразу пример задачи, сформулированной для нас нашим заказчиком неформально (то есть не математически):

`Определить по дате знак зодиака.`

Вот так звучит задача!

В таких случаях возникает вопрос: Откуда здесь начинать?!

Моя практика показывает, что лучше всего с конца!

От того насколько детально Вы в своем воображении представите этот "конец", тем больше вероятность, что:
- Вы выполните задачу правильно
- Вы выполните ее быстрее
- Вы совершите меньше ошибок по ходу решения
- Вы столкнетесь с меньшим количеством тупиков

Что же будет концом в нашей задачей?

Представим тот момент, когда мы завершили задачу, протестировали, и с гордостью передали ее заказчику с инструкциями, как ею пользоваться. Представим также улыбку удовлетворения заказчика.

И начнем разматывать время в обратном направлении к "началу". Что было началом в нашей задаче? Вероятно холодный пот на нашем лбу как результат реакции тела на мысль в уме: Как вообще к этой задаче подступиться?!

Если Вы - человек такого же типа как я, то сколько бы лет опыта не было за Вашими плечами, то история любой задачи развивается примерно по тому сценарию, который я только что описал. Ум реагирует одинаково каждый раз. Единственное, что меняется с опытом, это уверенность в подходе к мышлению. Уверенность, что ты можешь положиться на определенный метод, который практиковал много лет.

Итак, в нашем воображении есть идея/картинка "конца" и "начала" и дальше речь пойдет об определенном методе, то есть шагах от конца к началу. Еще раз, этот метод не про движение от начала к концу, а от конца к началу.

Что же предшествовало и вызвало улыбку удовлетворения заказчика? Очевидно, совпадение его ожиданий с реальностью. Если его/ее ожидания были получить программу, запускающуюся через командную строку, и именно такую программу мы сделали, то это ровно половина его улыбки. Вторая половина, это совпадение его/ее ожидания увидеть на экране название его/ее знака зодиака.

В его/ее командной строке это выглядит примерно так (продолжаем развивать нашу картинку "конца"):

```bash
$> node ./zodiak.js
Aries!
```

Примерно это Вы эму/ей предоставили в инструкциях, правильно? Причем здесь появляется первая ложка дегтя в этой нашей бочке меда. А что если у него/нее на компьютере не установлен Node? Тогда он/она не сможет запустить программу, и не будет этой самой улыбки. Вы удостоверились в "начале", что это именно то, что он/она ожидает? Может он/она - вообще не программист и даже слышать не хочет, что надо сначала установить Node. Может ему/ей хотелось получить от Вас файл, по которому "кликаешь два раза" и происходит магия и на экране появляется название его знака зодиака.

Предположим, в нашем случае, мы разузнали о его/ее ожиданиях в начале и знаем, что такое:

```bash
$> node ./zodiak.js
Aries!
```

его/ее полностью удовлетворит.

Начнем писать эту программу, которая будет воспроизводить реальность в одном шаге от "конца" в направлении "начала".

```js
// zodiak.js
console.log('Aries');
```

Voila! (как говорят франкофоны) Done! (как говорят англофоны)

Проверяем/тестируем:

```js
// zodiak.js
console.log('Aries');
```

Работает же?! Начните замечать, как та самая улыбка начинает расти у Вас в душе, и как она иссушивает тот холодный пот на Вашем лбу.

Но это конечно еще не все. Задача не выполнена. Ведь было сказано "по данной дате определить знак". А мы пока никакую дату не даем.

Это следующий шаг от "конца" в направлении "начала".

Формируем/детализируем нашу фантазию: Когда я сделаю этот шаг, то реальность будет выглядеть вот так в командной строке:

```bash
$> node ./zodiak.js
Введите дату: ???
Aries!
```

Хм, этот шаг уже кажется слишком большим, холодный пот возвращается! Поэтому мы поставили туда ???, ощутив величину шага и нашу неуверенность, что мы умеет такое.

Но глаза боятся, а руки делают, и чем меньше шаг, тем проще делать:

```js
// zodiak.js
console.log('Введите дату: ???');
console.log('Aries');
```

Тестируем:

```bash
$> node ./zodiak.js
Введите дату: ???
Aries!
```

Снова легкая уверенность, но все равно неопределенность. Знаний не хватает, как написать код, который будет "читать" из консоли. "Писать" туда умеем, а "читать" пока нет.

Перед нами большое решение:
- либо мы щас откладываем решение и идем читать том в 300 страниц энциклопедии по JavaScript на тему работы с консолью
- либо пытаемся "нагуглить" решение
- либо уточняем/меняем спецификацию

Вдруг нас осенило! А что, если дату не вводить через консоль, а менять каждый раз в файле `zodiak.js`?.. Долго стеснялись, сомневались, набрались мужества (задачу-то через час сдавать, а за час целый том не прочитаешь, да и это только капля в море по отношению ко всей задаче, чорт - этот пот снова!) и решились спросить у заказчика на счет такого решения.

Оказалось, что ему и не надо вообще вводить ничего через консоль. Ему оказывается нужна только функция, которая по заданной дате умеет выдавать знак зодиака!

То есть ему нужна функция `data => zodiak`! Пот опять высох, какой понимающий у меня заказчик! Он ведь знал, что невозможно эту задачу выполнить за час вместе с чтением из консоли! Жизнь снова прекрасна! Но возвращаемся к нашей задаче...

```js
// zodiak.js
function ???() {

}
console.log('Aries');
```

Нам же функция нужна, начали ее писать. И тут встретили на нашем пути одного из нескольких коварных врагов каждого программиста - naming devil, дьявола именования! Хммм, как же назвать эту функцию получше? Просидели так 10 мин в раздумьях по поводу идеяльности имени этой функции, очнулись, покрылись снова холодным потом, время тикает, в панике написали туда что-то, например `getZodiak`.

```js
// zodiak.js
function getZodiak() {

}
console.log('Aries');
```

Тут осознали, что, пока думали об имени, забыли вообще что эта функция должна делать, вернулись назад в своих мыслях, потеряли еще 2 минуты, вспомнили функция `date => zodiak`.

Вывод на будущее: гораздо важнее ЧТО это за функция (ее тип `date => zodiak`), чем ее название. Ну правда, задумайтесь над этим. Вам кажется, что Вы (или ваши соратники по команде) сразу поймете по названию функции, что она делает. Но проведите, эксперимент, поставьте напоминание на через месяц вернуться к этому коду и прочитать его. Через месяц название `getZodiak` может только взбередить Ваши собственные воспоминания на счет того, что же эта функция делала. Вашему соратнику само название скажем еще меньше.

Тип же, наоборот, скажем намного больше, чем название! Тип функции ответит на вопросы:
- какие аргументы (сколько их и каких они типов) функция принимает на вход
- значение какого типа производит эта функция (или какие эффекты производит эта функция)

Другими словами `foo('1984-03-25') => 'Aries'` (даже если это foo : string => string) говорит гораздо больше (несмотря на бессмысленное имя функции), чем "идеальное" название `getZodiak`. В действительности сочетание типа и осмысленного названия является лучшей комбинацией, передающей идею функции.

Но, я не устану утверждать, что тип - первичнее и следовательно важнее! Поэтому я так сам всегда делаю, и Вам советую, выбирать имя для функции из списка: `foo, bar, baz`.

Кроме того! С опытом Вы осознаете, что в 90% случаев Вы заканчиваете переименованием того имени, которые Вам казалось "идеальным" до начала написания функции. Это до сих пор справедливо и для меня, программиста с опытом 10+ лет. Я просто утратил веру в свою способность изобретать "идельные" имена. Но это только я, может у Вас будет получаться лучше ;-) Но я сомневаюсь.

А еще страшее ситуация, когда вы дали "идеальное" имя, а через неделю, закончив работать над задачей, осознали, что имя не только не идеальное, но и путающее, или имеющее противоположный смысл. Но осознали Вы это в 3 часа ночи, когда сил не было уже ни на что, подумали переименуете первым делом с утра... Это же надо другое идеальное имя щас придумать! Короче! Через год Ваш соратник пытается решить баг (тоже в 3 часа ночи), опираясь на понимание Вами написанной функции, основываясь на ее названии. Ну в общем Вы представляете какие слова звучат в Ваш адрес в той тихой ночи.

Вывод: имена функций (и переменных, да любые имена) не только безразличны, но и часто вредоносны! Так зачем тратить время на их придумывание? Сначала задача решается стройно и строго по типам, а когда написана и работает, "причесывается", в том числе даются удобные имена функциям и переменным.

Итак, где мы?

```js
// zodiak.js
function foo() {

}
console.log('Aries');
```

А точнее

```ts
// zodiak.ts
function foo(date : ?date) : ?zodiak {

}
console.log('Aries');
```

Теперь вопрос: какие типы (из имеющихся) мы можем использовать в качестве `?date` и `?zodiak`. Ну можем использовать `string`. Правда тогда сам тип (при наличии такого тупого имени функции, мало что скажет о том, что эта функция делает).

```ts
// zodiak.ts
function foo(date : string) : string {

}
console.log('Aries');
```

Здесь мы хотя бы дали хорошее имя аргументу. Хотя бы понятно, что какая-то дата вводится в виде строки, но что за строку выводит эта функция?..

Если у нас не особо много времени, то мы можем и так оставить, ну дать имя `getZodiak`.

```ts
// zodiak.ts
function getZodiak(date : string) : string {

}
console.log('Aries');
```

Но если у нас хорошо вымуршрована привычка работы с типами, то мы используем `type alias`.

```ts
// zodiak.ts
type Date = string;
type Zodiak = string;

function foo(date : Date) : Zodiak {

}
console.log('Aries');
```

Согласитесь, понятно ЧТО делает эта функция, даже несмотря на то, что имя у нее ничего не значит?

Даже сделаем, еще одно улучшение. Знаки зодиака - это же на все на свете возможные строки? Кардиналити типа `string` = бесконечности, а множество имен зодиака вполне ограничено - 12. Для этого подойдет `перечисление`.

```ts
// zodiak.ts
type Date = string;
type Zodiak = 'Aries' | "blah blah blah";

function foo(date : Date) : Zodiak {

}
console.log('Aries');
```

Времени щас перечислять все знаки нету, это мы умеем, это быстро и много ума не надо. Не тратим время на это! Можем опыть забыть, что делаем.

```ts
// zodiak.ts
type Date = string;
type Zodiak = 'Aries' | "blah blah blah";

function foo(date : Date) : Zodiak {
    ???
}
console.log('Aries');
```

Когда эта функция будет готова (опять движемся с конца), мы будем ее как-то использовать для тестирования. Например вот так

```ts
// zodiak.ts
type Date = string;
type Zodiak = 'Aries' | "blah blah blah";

function foo(date : Date) : Zodiak {
    ???
}
console.log(
    foo('asdfas')
);
```

Тестируем!

```bash
$> tsc zodiak.ts                                                                                                                               11:09:29
zodiak.ts:6:5 - error TS1109: Expression expected.

6     ???
      ~~

zodiak.ts:6:7 - error TS1109: Expression expected.

6     ???
        ~

zodiak.ts:7:1 - error TS1109: Expression expected.

7 }
  ~


Found 3 errors in the same file, starting at: zodiak.ts:6
```

Ах да да да! Забыли про ??? Есть очень большой психологический смысл делать маленькие шаги и тестировать после каждого. Такое поведение позволяет испытать вспышку серотонина по двум причинам
- либо потому что ожидания совпадают с происходящим (а ведь и не верилось, что будет работать) - 1 категория
- либо потому, что есть проблема, но такая маленькая, такая решаемая, что нам радостно и мы бросаемся в действие - 2 категория

Наше действие должно быть наисмешнейше маленьким, минимально необходимым для решения проблемы

```typescript
// zodiak.ts
type Date = string;
type Zodiak = 'Aries' | "blah blah blah";

function foo(date : Date) : Zodiak {
    return 'asdfasf';
}
console.log(
    foo('asdfas')
);
```

Тестируем! Заметьте с позитивным трепетом в сердце, как в ожидании свадания, а не с тревогой, как при ожидании экзамена.

```bash
$> tsc zodiak.ts
../../.nvm/versions/node/v14.19.3/lib/node_modules/typescript/lib/lib.es5.d.ts:755:11 - error TS2300: Duplicate identifier 'Date'.

755 interface Date {
              ~~~~

  zodiak.ts:2:6
    2 type Date = string;
           ~~~~
    'Date' was also declared here.

../../.nvm/versions/node/v14.19.3/lib/node_modules/typescript/lib/lib.es5.d.ts:933:13 - error TS2300: Duplicate identifier 'Date'.

933 declare var Date: DateConstructor;
                ~~~~

  zodiak.ts:2:6
    2 type Date = string;
           ~~~~
    'Date' was also declared here.

../../.nvm/versions/node/v14.19.3/lib/node_modules/typescript/lib/lib.es5.d.ts:4481:11 - error TS2300: Duplicate identifier 'Date'.

4481 interface Date {
               ~~~~

  zodiak.ts:2:6
    2 type Date = string;
           ~~~~
    'Date' was also declared here.

../../.nvm/versions/node/v14.19.3/lib/node_modules/typescript/lib/lib.scripthost.d.ts:325:11 - error TS2300: Duplicate identifier 'Date'.

325 interface Date {
              ~~~~

  zodiak.ts:2:6
    2 type Date = string;
           ~~~~
    'Date' was also declared here.

zodiak.ts:2:6 - error TS2300: Duplicate identifier 'Date'.

2 type Date = string;
       ~~~~

  ../../.nvm/versions/node/v14.19.3/lib/node_modules/typescript/lib/lib.es5.d.ts:755:11
    755 interface Date {
                  ~~~~
    'Date' was also declared here.
  ../../.nvm/versions/node/v14.19.3/lib/node_modules/typescript/lib/lib.es5.d.ts:933:13
    933 declare var Date: DateConstructor;
                    ~~~~
    and here.
  ../../.nvm/versions/node/v14.19.3/lib/node_modules/typescript/lib/lib.es5.d.ts:4481:11
    4481 interface Date {
                   ~~~~
    and here.
  ../../.nvm/versions/node/v14.19.3/lib/node_modules/typescript/lib/lib.scripthost.d.ts:325:11
    325 interface Date {
                  ~~~~
    and here.

zodiak.ts:6:5 - error TS2322: Type '"asdfasf"' is not assignable to type 'Zodiak'.

6     return 'asdfasf';
      ~~~~~~~~~~~~~~~~~

zodiak.ts:9:9 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'Date'.

9     foo('asdfas')
          ~~~~~~~~


Found 7 errors in 3 files.

Errors  Files
     3  ../../.nvm/versions/node/v14.19.3/lib/node_modules/typescript/lib/lib.es5.d.ts:755
     1  ../../.nvm/versions/node/v14.19.3/lib/node_modules/typescript/lib/lib.scripthost.d.ts:325
     3  zodiak.ts:2
```

Боже мой! Волосы дыбом стынут в жилах. Пот! Паника! Зачем я вообще все усложняю?! Все бросить! Быть проще!

Стоп! Не паникуем, пробуем разобраться. Потому что опыт показывает, что с "простым" решение всегда сложнее. И опыт показывает надо доверять методу!

Ага, тип мы назвали как нельзя было, во-первых.

```ts
// zodiak.ts
type _Date = string;
type Zodiak = 'Aries' | "blah blah blah";

function foo(date : _Date) : Zodiak {
    return 'asdfasf';
}
console.log(
    foo('asdfas')
);
```

Тестируем!

```bash
$> tsc zodiak.ts
zodiak.ts:6:5 - error TS2322: Type '"asdfasf"' is not assignable to type 'Zodiak'.

6     return 'asdfasf';
      ~~~~~~~~~~~~~~~~~


Found 1 error in zodiak.ts:6
```

Ага! Было 7 ошибок, стало 1 - серотониииииин 2й категории

Смотрим! А ну да! Поторопились, ограничили тип `Zodiak` набором значений, а сами возвращаем то, что в наборе нет.

```ts
// zodiak.ts
type _Date = string;
type Zodiak = 'Aries' | "blah blah blah";

function foo(date : _Date) : Zodiak {
    return 'Aries';
}
console.log(
    foo('asdfas')
);
```

Тестируем!

```bash
$> tsc zodiak.ts
$> node zodiak.js
Aries
```

Voila! (как говорят франкофоны) Done! (как говорят англофоны) - серотониииин 1й категории

Можно даже пойти "перекурить", как после свидания, не как после проваленного экзамена. Или стоп! Курить - здоровью вредить!

Что дальше?

Теперь он нам всегда только `Aries` выдает и дату вообще не учитывает. Что нам вообще делать с этой датой?

Тут попробуйте продолжить решение сами. Иначе, смотри [Зодиак 2](zodiak-2.md)
